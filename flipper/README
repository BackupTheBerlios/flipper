This is the README of flipper.

Flipper is a program that does randomised local search for
satisfiability of 3 variable sentences on prenex normal form
in the pure predicate calculus. It does so by proving satisfiability
relative to given decidable theories.

Flipper will terminate successfully if the input is satisfiable,
othewise it will keep on running, usually/always till resources
are exhausted.

Provided the random generator is on your side, flipper will terminate
successfully if the input is satisfiable over some finite structure.
Besides there are some some inputs not satisfiable
by any finite structure for which flipper terminates.

The intended use of flipper is as a complement to theorem provers
and finite model generators in deciding the satisfiability of
given sentences. Flipper could for instance be usefull in software
verification as some questions in various temporal logics translate
quite naturally to a format tractable by flipper.


REQUIREMENTS

bash
make
gcc
gnu-prolog


INSTALATION

edit Makefile # especially the BIN_DIRECTORY variable
make
make install


RUNNING

flipper file.fo
and
fo2tptp < file.fo


where file.fo is a file whose contents has the following form;

Sentence.

here Sentence is specified as follows;

(Sentence & Sentence) - conjunction
aaa(Matrix)         - for all x y z (Matrix)
aae(Matrix)         - for all x y there exists z (Matrix)
aea(Matrix)         - for all x there exists y for all z (Matrix)
aee(Matrix)         - for all x there exist x y (Matrix)
eaa(Matrix)
eae(Matrix)
eea(Matrix)
eee(Matrix)

here Matrix has the following form;

(Matrix & Matrix) - conjunction
(Matrix v Matrix) - disjunction
(Matrix => Matrix) - implication
-(Matrix)          - negation
Relation(x)
Relation(y)
Relation(z)
Relation(xx)
Relation(xy)
Relation(xz)
Relation(yx)
Relation(yy)
Relation(yz)
Relation(zx)
Relation(zy)
Relation(zz)

where Relation denotes any sequence of 
letters the first of which is lower case.

Note that flipper does not recognize equality or function-sybols,
these have to be defined as in the examples below.


EXAMPLES

Here are some examples of formulae that don't have finite models.
The symbol % means that the rest of the line is a comment.

example 1; an irreflexive transitive unbounded relation 

aaa(-lth(xx)) &
aae( lth(xz)) &
aaa((lth(xy) & lth(yz)) => lth(xz)).


example 2; an injective endo-function whose image is not entire

aaa(equal(xx)) &
aaa(equal(xy) => equal(yx)) &
aaa((equal(xy) & equal(yz)) => equal(xz)) &
aaa((f(xy) & equal(xz)) => f(zy)) & 	   	%substitution
aaa((f(xy) & equal(yz)) => f(xz)) & 	       	%substitution
aae(f(xz)) &                        		%f is total
aaa((f(xy) & f(xz)) => equal(yz)) & 		%f is a function
aaa((f(xy) & f(zy)) => equal(xz)) & 		%f is injective
aea(-f(zy)). 	       		    		%f's image is not total


example 3; the same as the example above except relativized to a
predicate dom

aaa(equal(xx)) &
aaa(equal(xy) => equal(yx)) &
aaa((equal(xy) & equal(yz)) => equal(xz)) &
aaa((dom(x) & equal(xy)) => dom(y)) &	   		%substitution
aaa((dom(x) & equal(xy)) => dom(y)) & 		%substitution
aae(dom(z)) &
aaa((dom(x) & dom(y) & f(xy) & equal(xz)) => f(zy)) & %substitution
aaa((dom(x) & dom(y) & f(xy) & equal(yz)) => f(xz)) & %substitution
aae(dom(x) => (f(xz) & dom(z))) &            	      	%f is a function
aaa((dom(x) & dom(y) & f(xy) & f(xz)) => equal(yz)) & %f is a function
aaa((dom(x) & dom(y) & f(xy) & f(zy)) => equal(xz)) & %f is injective
aea(dom(z) & dom(y) & -f(zy)).



NOTES

There quite probably still are bugs in flipper.
If you find some please let me know (rognes
at berlios.de). Also let me know if you get flipper
to work for something fun, usefull or otherwise interesting.


I hope to get something published on the inner workings of flipper
soon.



André Rognes
